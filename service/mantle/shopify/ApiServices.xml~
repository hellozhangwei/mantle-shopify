<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <service verb="send" noun="SystemMessageRest">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="response"/>
            <parameter name="systemMessage"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>
            <set field="systemMessageType" from="systemMessage.'moqui.service.message.SystemMessageType'"/>

            <if condition="!systemMessage.systemMessageRemoteId">
                <return error="true"
                        message="System message ${systemMessageId} has no systemMessageRemoteId, not sending."/>
            </if>
            <set field="systemMessageRemote" from="systemMessage.'moqui.service.message.SystemMessageRemote'"/>
            <set field="docSubType" from="systemMessage.docSubType?:''"/>
            <set field="response" value=""/>
            <script>import groovy.json.JsonSlurper</script>
            <script><![CDATA[
                def jsonSlurper = new JsonSlurper()
                String urlExpand = ec.resource.expand(systemMessageRemote.sendUrl, "systemMessage", [remoteMessageId:systemMessage.systemMessageId,
                        systemMessageTypeId:systemMessage.systemMessageTypeId, systemMessageRemoteId:systemMessage.systemMessageRemoteId], false)
                logger.info("SENDING MESSAGE TEXT ${systemMessage.messageText}")
                org.moqui.util.RestClient restClient = ec.service.rest()
                if(docSubType.contains("delete")){
                    urlExpand = urlExpand + systemMessage.messageText + ".json"
                    logger.info("URL EXPAND ${urlExpand}")
                    restClient = ec.service.rest().method(org.moqui.util.RestClient.DELETE).uri(urlExpand)
                }else if(docSubType.contains("get")){
                    urlExpand = urlExpand + systemMessage.messageText
                    logger.info("URL EXPAND ${urlExpand}")
                    restClient = ec.service.rest().method(org.moqui.util.RestClient.GET).uri(urlExpand)
                }else{
                    logger.info("URL EXPAND ${urlExpand}")
                    restClient = ec.service.rest().method(org.moqui.util.RestClient.POST).uri(urlExpand)
                            .addHeader("Content-Type", "application/json").jsonObject(systemMessage.messageText)
                }
                restClient.basicAuth(systemMessageRemote.username,systemMessageRemote.password)
                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 300) {
                    String errMsg = restResponse.text()
                    ec.message.addError("System message ${systemMessageId} send error response (${restResponse.statusCode}): ${errMsg}")
                    return
                }
                response = jsonSlurper.parseText(restResponse.text())
            ]]></script>

            <!-- TODO: WebFacadeImpl.handleSystemMessage() will need to return a message ID before we can do this: <set field="remoteMessageId" from=""/> -->
        </actions>
    </service>

    <service verb="get" noun="ProductData">
        <in-parameters>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productData"/>
        </out-parameters>
        <actions>
            <script>import groovy.json.JsonSlurper</script>
            <entity-find-one entity-name="mantle.product.Product" value-field="product">
                <field-map field-name="productId"/>
            </entity-find-one>
            <entity-find-one entity-name="mantle.product.ProductContent" value-field="productContent">
                <field-map field-name="productId"/>
                <field-map field-name="productContentTypeEnumId" value="PcntImageDetail"/>
            </entity-find-one>
            <set field="images" from="[]"/>
            <set field="prodVariants" from="[]"/>
            <set field="prodOptions" from="[]"/>
            <set field="prodOptionsMap" from="new HashMap()"/>
            <!-- HOW TO GET THIS ROUTE WITHOUT BURNED IT -->
            <if condition="productContent">
                <set field="image" from="[src: 'https://www.rcherbals.com/store/content/productImage/' + productContent.productContentId]"/>
                <script>images.add(image)</script>
            </if>
            <if condition="product.productTypeEnumId == 'PtVirtual'">
                <then>
                    <!-- Get all the products associated to the parent product /-->
                    <entity-find entity-name="mantle.product.ProductAssoc" list="assocList">
                        <econdition field-name="productId"/>
                        <econdition field-name="fromDate" operator="is-not-null"/>
                        <econdition field-name="thruDate" operator="is-null"/>
                    </entity-find>
                    <iterate list="assocList" entry="assoc">
                        <!-- Each product associated has at least one feature so we get all posible features /-->
                        <entity-find entity-name="mantle.product.feature.ProductAndFeatureAndFeatureAppl" list="featureList">
                            <econdition field-name="productId" from="assoc.toProductId"/>
                            <econdition field-name="fromDate" operator="is-not-null"/>
                            <econdition field-name="thruDate" operator="is-null"/>
                            <order-by field-name="productFeatureDescription"/>
                        </entity-find>

                        <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceSet" in-map="[productId:assoc.toProductId]"/>

                        <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="prodUPC">
                            <field-map field-name="productId" from="assoc.toProductId"/>
                            <field-map field-name="productIdTypeEnumId" value="PidtUpca"/>
                        </entity-find-one>

                        <script><![CDATA[
                            /**
                                The featureList is the list of all the features that an assoc has,
                                if it's only one feature, we don't need to make the combinations
                                if it the product has more than one feature we have to make the combinations
                                in order to follow the shopify format.

                                NOTE: Shopify supports products that has at most 3 features.
                            **/
                            if(featureList.size() == 1){
                                prodVariants.add(new HashMap([name:featureList[0].productFeatureDescription, option1:featureList[0].productFeatureDescription, price:priceSet.price, barcode: prodUPC.idValue]))
                            }else if(featureList.size() == 2){
                                prodVariants.add(new HashMap([name:featureList[0].productFeatureDescription + "/" + featureList[1].productFeatureDescription, option1:featureList[0].productFeatureDescription, option2:featureList[1].productFeatureDescription, price:priceSet.price, barcode: prodUPC.idValue]))
                            }else if(featureList.size() == 3){
                                prodVariants.add(new HashMap([name:featureList[0].productFeatureDescription + "/" + featureList[1].productFeatureDescription + "/" + featureList[2].productFeatureDescription, option1:featureList[0].productFeatureDescription, option2:featureList[1].productFeatureDescription, option3:featureList[2].productFeatureDescription, price:priceSet.price, barcode: prodUPC.idValue]))
                            }
                        ]]>
                        </script>
                        <iterate list="featureList" entry="feature">
                            <set field="item" from="feature.productFeatureTypeEnumId"/>
                            <script><![CDATA[
                                def optionSet = prodOptionsMap.get(item)
                                if (!optionSet) {
                                    prodOptionsMap.put(item, [feature.productFeatureDescription])
                                } else {
                                    if(!optionSet.contains(feature.productFeatureDescription)){
                                       optionSet.add(feature.productFeatureDescription)
                                    }
                                }
                            ]]></script>
                        </iterate>
                        <!-- MAKE THE COMBINATIONS FOR THE PRODUCT WITH THE FEATURELIST  /-->
                    </iterate>
                    <script><![CDATA[
                        String[] keyList = prodOptionsMap.keySet()
                        if(keyList.length == 1){
                            def options1 = prodOptionsMap.get(keyList[0])
                            prodOptions.add(new HashMap([name:keyList[0], values:options1]))
                        }else if(keyList.length == 2){
                            def options1 = prodOptionsMap.get(keyList[0])
                            def options2 = prodOptionsMap.get(keyList[1])
                            prodOptions.add(new HashMap([name:keyList[0], values:options1]))
                            prodOptions.add(new HashMap([name:keyList[1], values:options2]))
                        }else if(keyList.length == 3){
                            def options1 = prodOptionsMap.get(keyList[0])
                            def options2 = prodOptionsMap.get(keyList[1])
                            def options3 = prodOptionsMap.get(keyList[2])
                            prodOptions.add(new HashMap([name:keyList[0], values:options1]))
                            prodOptions.add(new HashMap([name:keyList[1], values:options2]))
                            prodOptions.add(new HashMap([name:keyList[2], values:options3]))
                        }
                    ]]></script>
                    <log message="OPTIONS ${prodOptions}"/>
                </then>
            </if>
            <set field="productData" from="[title: product.productName,
                                        body_html: '',
                                        vendor: '',
                                        images: images,
                                        variants: prodVariants,
                                        options: prodOptions]"/>
        </actions>
    </service>
    
    <service verb="queue" noun="ProductSystemMessage">
        <in-parameters>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ProductData" 
                          in-map="[productId: productId, productStoreId: productStoreId]"
                          out-map="context" />

            <set field="json" from="groovy.json.JsonOutput.toJson([product: productData])"/>

            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the product JSON as messageText/-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                    in-map="[systemMessageTypeId:'ShopifyProductMessage', systemMessageRemoteId:'DEMO_SHOPIFY_PRODUCTS_REMOTE',
                        messageText:json, productId:productId]"/>
        </actions>
    </service>

    <service verb="send" noun="ProductSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
            <if condition="response.product.variants.size &gt; 0">
                <set field="shopifyVariants" from="response.product.variants"/>
                <log message="VARIANTS ${shopifyVariants}"/>
                <iterate list="shopifyVariants" entry="shopifyVariant">
                    <entity-find entity-name="mantle.product.ProductIdentification" list="prodUPCs">
                        <econdition field-name="idValue" from="shopifyVariant.barcode"/>
                    </entity-find>
                    <set field="productId" from="prodUPCs.first().productId"/>
                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" in-map="[productId:productId, productIdTypeEnumId:'PidtVariantShopify', idValue: shopifyVariant.id]"/>
                </iterate>
            </if>
            <service-call name="create#mantle.product.ProductIdentification" out-map="context" in-map="[productId:systemMessage.productId, productIdTypeEnumId:'PidtShopify', idValue: response.product.id]"/>
        </actions>
    </service>

    <service verb="get" noun="ProductCategoryData">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryData"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="productCategory">
                <field-map field-name="productCategoryId"/>
            </entity-find-one>
            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>
            <script>import groovy.json.JsonSlurper</script>
            <set field="shopifyCollectItems" from="[]"/>
            <iterate list="productCategoryMembers" entry="productCategoryMember">
                <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productIdentification">
                    <field-map field-name="productId" from="productCategoryMember.productId"/>
                    <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                </entity-find-one>
                <if condition="productIdentification">
                    <entity-find-one entity-name="mantle.product.Product" value-field="product">
                        <field-map field-name="productId" from="productCategoryMember.productId"/>
                    </entity-find-one>
                    <script>
                        <![CDATA[
                            shopifyCollectItems.add(new HashMap([product_id:productIdentification.idValue]))
                        ]]>
                    </script>
                </if>
            </iterate>
            <if condition="shopifyCollectItems.size &gt; 0"><then>
                <set field="productCategoryData" from="[title: productCategory.categoryName, collects: shopifyCollectItems]"/>
            </then><else>
                <set field="productCategoryData" from="[title: productCategory.categoryName]"/>
            </else></if>
        </actions>
    </service>

    <service verb="queue" noun="CreateCollectionSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ProductCategoryData"
                          in-map="[productCategoryId: productCategoryId, productStoreId: productStoreId]"
                          out-map="context" />

            <set field="json" from="groovy.json.JsonOutput.toJson([custom_collection: productCategoryData])"/>

            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collection JSON as messageText/-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyCreateCollectionMessage', systemMessageRemoteId:'DEMO_SHOPIFY_CREATE_COLLECTION_REMOTE',
                        messageText:json, productCategoryId:productCategoryId]"/>
        </actions>
    </service>

    <service verb="send" noun="CreateCollectionSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />

            <service-call name="update#mantle.product.category.ProductCategory" out-map="context" in-map="[productCategoryId:systemMessage.productCategoryId, pseudoId:response.custom_collection.id]"/>
        </actions>
    </service>

    <service verb="get" noun="ShopifyCollectionData">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="shopifyCollectionId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="productCategory">
                <field-map field-name="productCategoryId"/>
            </entity-find-one>
            <set field="shopifyCollectionId" from="productCategory.pseudoId"/>
        </actions>
    </service>

    <service verb="queue" noun="DeleteCollectionSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ShopifyCollectionData"
                          in-map="[productCategoryId: productCategoryId]"
                          out-map="context" />

            <set field="idParam" from="shopifyCollectionId"/>

            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collection JSON as messageText/-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyDeleteCollectionMessage', systemMessageRemoteId:'DEMO_SHOPIFY_DELETE_COLLECTION_REMOTE',
                            messageText:idParam, productCategoryId:productCategoryId, docSubType: 'deleteCollection']"/>
        </actions>
    </service>

    <service verb="send" noun="DeleteCollectionSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />

            <service-call name="update#mantle.product.category.ProductCategory" out-map="context" in-map="[productCategoryId:systemMessage.productCategoryId, pseudoId:'']"/>

            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>

            <iterate list="productCategoryMembers" entry="productCategoryMember">
                <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="productCategoryMember + [pseudoId:'']"/>
            </iterate>
        </actions>
    </service>

    <service verb="get" noun="ProductCategoryMemberData">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="collectData"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="productCategory">
                <field-map field-name="productCategoryId" from="productCategoryId"/>
            </entity-find-one>

            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productIdentification">
                <field-map field-name="productId" from="productId"/>
                <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
            </entity-find-one>
            <set field="collectData" value="."/>
            <if condition="productIdentification">
                <script>
                    <![CDATA[
                        collectData = [product_id:productIdentification.idValue, collection_id:productCategory.pseudoId]
                    ]]>
                </script>
            </if>
        </actions>
    </service>

    <service verb="queue" noun="CreateCollectSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ProductCategoryMemberData"
                          in-map="[productCategoryId: productCategoryId, productId: productId]"
                          out-map="context" />

            <set field="json" from="groovy.json.JsonOutput.toJson([collect: collectData])"/>
            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collection JSON as messageText/-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyCreateCollectMessage', systemMessageRemoteId:'DEMO_SHOPIFY_CREATE_COLLECT_REMOTE',
                        messageText:json, productCategoryId:productCategoryId, productId:productId]"/>
        </actions>
    </service>

    <service verb="send" noun="CreateCollectSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />

            <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="[productId:systemMessage.productId, productCategoryId:systemMessage.productCategoryId, pseudoId:response.collect.id]"/>

        </actions>
    </service>

    <service verb="queue" noun="GetCollectSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ProductCategoryMemberData"
                          in-map="[productCategoryId: productCategoryId, productId: productId]"
                          out-map="context"/>
            <set field="shopifyGetCollectParams" from="'?product_id='+collectData.product_id+'&amp;'+'collection_id='+collectData.collection_id"/>
            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collection JSON as messageText/-->

            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyGetCollectMessage', systemMessageRemoteId:'DEMO_SHOPIFY_GET_COLLECT_REMOTE',
                            messageText:shopifyGetCollectParams, productCategoryId:productCategoryId, productId:productId, docSubType: 'getCollect']"/>
        </actions>
    </service>

    <service verb="send" noun="GetCollectSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="shopifyId"/>
        </out-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context"/>

            <set field="shopifyId" from="response.collects[0].id"/>
        </actions>
    </service>

    <service verb="queue" noun="DeleteCollectSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.queue#GetCollectSystemMessage"
                          in-map="[productCategoryId: productCategoryId, productId: productId]"
                          out-map="context"/>

            <log message="ID ${shopifyId}"/>

            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collection JSON as messageText/-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyDeleteCollectMessage', systemMessageRemoteId:'DEMO_SHOPIFY_DELETE_COLLECT_REMOTE',
                            messageText:idParam, productCategoryId:productCategoryId, productId:productId, docSubType: 'deleteCollect']"/>
        </actions>
    </service>

    <service verb="send" noun="DeleteCollectSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context"/>

            <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="[productCategoryId:systemMessage.productCategoryId, productId:systemMessage.productId, pseudoId:'']"/>
        </actions>
    </service>

    <service verb="queue" noun="GetOrdersSystemMessage">
        <in-parameters>
            <parameter name="ordersStatus" required="true">
                <description>
                    The shopify status of the orders we want to retrieve, supported statuses are:
                    any: Show orders of any financial status.
                    authorized: Show only authorized orders
                    pending: Show only pending orders
                    paid: Show only paid orders
                    partially_paid: Show only partially paid orders
                    refunded: Show only refunded orders
                    voided: Show only voided orders
                    partially_refunded: Show only partially refunded orders
                    unpaid: Show authorized and partially paid orders.
                </description>
            </parameter>
        </in-parameters>
        <actions>
            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collection JSON as messageText/-->

            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyGetOrdersMessage', systemMessageRemoteId:'DEMO_SHOPIFY_GET_ORDERS_REMOTE', messageText: ordersStatus, docSubType: 'getOrders']"/>
        </actions>
    </service>

    <service verb="send" noun="GetOrdersSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context"/>
            <set field="orderList" from="response.orders"/>
            <log message="ORDER LENGTH ${orderList[0]}"/>

        </actions>
    </service>

    <service verb="get" noun="VirtualProductData">
        <in-parameters>
            <parameter name="productId">
                <description>Only id of a virtual product make sense to get relevant data.</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="featureType"></parameter>
            <parameter name="variantOptions" type="Map">
                <description>
                    A map where key is feature type (Enumeration) and value is another map
                    with productId, description and price data exactly as it returned by get#ProductPrice.
                </description>
            </parameter>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.Product" value-field="product"/>

            <set field="variantOptions" type="NewMap" value="null"/>
            <script>variantOptions = new HashMap()</script>
            <set field="isDiscounted" type="Boolean" value="false"/>

            <service-call name="mantle.product.PriceServices.get#ProductPrice" in-map="context" out-map="mainPriceSet"/>

            <if condition="product &amp;&amp; product.productTypeEnumId == 'PtVirtual'">
                <entity-find entity-name="mantle.product.ProductAssocAndToFeatureAppl" list="assocs">
                    <econdition field-name="productAssocTypeEnumId" value="PatVariant"/>
                    <econdition field-name="applTypeEnumId" operator="in" value="PfatDistinguishing, PfatStandard"/>
                    <econdition field-name="productId" from="product.productId"/>
                    <econdition field-name="thruDate" operator="is-null"/>
                    <date-filter/>
                </entity-find>
                <set field="listFeatures" type="NewMap" value="null"/>
                <script>listFeatures = new HashMap()</script>
                <iterate list="assocs" entry="variantProductAssoc">
                    <!-- find variant price first -->
                    <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceSet"
                                  in-map="context + [productId:variantProductAssoc.toProductId]"/>
                    <entity-find entity-name="mantle.product.feature.ProductFeatureAndAppl" list="features">
                        <date-filter/>
                        <econdition field-name="productId" from="variantProductAssoc.toProductId"/>
                        <econdition field-name="productFeatureId" from="variantProductAssoc.productFeatureId"/>
                        <econdition field-name="thruDate" operator="is-null"/>
                    </entity-find>

                    <!-- we return map keyed by feature type and should find the proper value for the assoc -->
                    <entity-find-one entity-name="mantle.product.feature.ProductFeature" value-field="productFeature"
                                     cache="true">
                        <field-map field-name="productFeatureId" from="variantProductAssoc.productFeatureId"/>
                    </entity-find-one>

                    <service-call name="mantle.product.AssetServices.get#AvailableInventory" out-map="atpTotal"
                                  in-map="[productId:variantProductAssoc.toProductId]"/>

                    <entity-find-one entity-name="moqui.basic.Enumeration" value-field="featureType" cache="true">
                        <field-map field-name="enumId" from="productFeature.productFeatureTypeEnumId"/>
                    </entity-find-one>

                    <!-- Find variant contents ... need to use services in Mantle USL
                    <service-call name="popstore.ProductServices.find#ProductContentList" out-map="context"
                                  in-map="[productId:variantProductAssoc.toProductId]"/>
                    -->

                    <!-- Find product sales dates ... need to use services in Mantle USL
                    <service-call name="popstore.ProductServices.find#ProductSalesDates" out-map="context"
                                  in-map="[productId:variantProductAssoc.toProductId]"/>
                    -->

                    <set field="item" from="[enumId:featureType.enumId]"/>
                    <set field="content" from="productFeature.productFeatureTypeEnumId"/>
                    <script><![CDATA[
                        def optionSet = variantOptions.get(item)
                        if (!optionSet) {
                            variantOptions.put(item, [[productId: variantProductAssoc.toProductId, description:productFeature.description]])
                        } else {
                            optionSet.add([productId: variantProductAssoc.toProductId, description:productFeature.description])
                        }
                        priceSet = null
                    ]]></script>
                </iterate>
            </if>
        </actions>
    </service>

</services>