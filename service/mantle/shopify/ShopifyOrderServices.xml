<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">
	<!-- 
        Endpoint to pull down orders from Shopify.

        https://{store_name}.myshopify.com/admin/api/2023-04/orders.json?limit={limit}&fulfillment_status={status}&since_id={order_id}
    -->
    <service verb="download" noun="ShopifyOrders">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="fulfillmentStatus" default-value="unfulfilled"/>
            <parameter name="limit" default-value="250"/>
        </in-parameters>
        <out-parameters>
            <parameter name="systemMessageId"/>
        </out-parameters>
        <actions>
            <script>import groovy.json.JsonSlurper</script>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="systemMessageRemoteId"/>
            </entity-find-one>

            <if condition="!remote"><return error="true" message="No Remote of type 'ShopifySystemMessageType' found for ID ${systemMessageRemoteId}"/></if>

            <!-- see if we have called this before and what was the last order found on previous message -->
            <entity-find entity-name="moqui.service.message.SystemMessage" limit="1" list="prevMessages">
                <econdition field-name="systemMessageTypeId" value='ShopifySystemMessageType'/>
                <econdition field-name="systemMessageRemoteId"/>
                <econdition field-name="docType" value="orderList"/>
                <order-by field-name="initDate"/>
            </entity-find>
            <if condition="prevMessages">
                <set field="lastOrderId" from="prevMessages.first().docControl"/>
            </if>

            <!-- https://{hostname}/admin/api/{version}/{resource}.json?limit=250&fulfillment_status=unfulfilled&since_id={last} -->
            <script><![CDATA[
                String url = ec.resource.expand(remote.sendUrl, "", [resource:"orders"]) +
                    "?limit=${limit}&fulfillment_status=${fulfillmentStatus}";

                if (lastOrderId != null) {
                    url += "&since_id=${lastOrderId}";
                }

                org.moqui.util.RestClient restClient = ec.service.rest().method("GET")
                    .addHeader("Content-Type", "application/json")
                    .basicAuth(remote.username, remote.password)
                    .uri(url);

                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()

                if (restResponse.statusCode != 200) {
                    ec.logger.error("Shopify Orders API Response ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()} for url: ${url}")
                    return
                }
                Map messageMap = new JsonSlurper().parseText(restResponse.text());
                String lastOrderId = messageMap.orders ? messageMap.orders.last().id : null;
            ]]></script>

            <if condition="lastOrderId">
                <service-call name="create#moqui.service.message.SystemMessage" out-map="context" in-map="[
                    systemMessageTypeId:'ShopifySystemMessageType', systemMessageRemoteId:systemMessageRemoteId,
                    messageText:restResponse.text(), docType:'orderList', docControl:lastOrderId,
                    isOutgoing:'N', initDate:ec.user.nowTimestamp, statusId:'SmsgReceived']"/>
            </if>
        </actions>
    </service>


    <!-- consume the list of orders and generate individual system messages -->
    <service verb="consume" noun="OrderListSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <script>
                import groovy.json.JsonSlurper;
                import groovy.json.JsonOutput;
            </script>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>
            <set field="messageMap" from="new JsonSlurper().parseText(systemMessage.messageText)"/>

             <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>

            <iterate list="messageMap.orders" entry="order">
				<script><![CDATA[
                    String url = ec.resource.expand(remote.sendUrl, "", [resource: "${order.id}/fulfillment_orders"]);
                    org.moqui.util.RestClient restClient = ec.service.rest().method("GET")
                        .addHeader("Content-Type", "application/json")
                        .basicAuth(remote.username, remote.password)
                        .uri(url);

                    org.moqui.util.RestClient.RestResponse restResponse = restClient.call()

                    if (restResponse.statusCode != 200) {
                        ec.logger.error("Shopify Orders API Response ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()} for url: ${url}")
                    } else {
                    	Map responseMap = new JsonSlurper().parseText(restResponse.text());
                    }
                ]]></script>

                <service-call name="create#moqui.service.message.SystemMessage" out-map="context"
                                in-map="[systemMessageTypeId:'ShopifySystemMessageType', 
                                parentMessageId: systemMessage.systemMessageId,
                                messageText:JsonOutput.toJson([order:order, fulfillments:responseMap]), docType:'order', 
                                isOutgoing:'N', initDate:ec.user.nowTimestamp, statusId:'SmsgReceived']"/>

                <!-- immediately try to consume the order message -->
                <service-call name="org.moqui.impl.SystemMessageServices.consume#ReceivedSystemMessage"
                    in-map="[systemMessageId:systemMessageId, allowError:false]" async="true"/>
            </iterate>
        </actions>
    </service>

    <!-- consume order-->
    <service verb="consume" noun="OrderSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage" for-update="true"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="systemMessageRemote">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <set field="messageMap" from="new groovy.json.JsonSlurper().parseText(systemMessage.messageText)"/>

            <service-call name="mantle.shopify.ApiServices.consume#ShopifyOrderMap"
                    in-map="[order:messageMap.order, productStoreId:systemMessageRemote.productStoreId]" out-map="context"/>

            <!-- not sure what to do with orders that are missing the fulfillment message -->
            <if condition="messageMap.fulfillments">
            	<service-call name="mantle.shopify.ApiServices.consume#ShopifyFulfillmentsMap"
                    in-map="[fulfillments:messageMap.fulfillments, orderId:orderId]"/>
            </if>

            <set field="systemMessage.orderId" from="orderId"/>
            <entity-update value-field="systemMessage"/>
        </actions>
    </service>

    <!-- cancelOrder -->




    <!-- -->


    <!-- cancelOrder -->
</services>